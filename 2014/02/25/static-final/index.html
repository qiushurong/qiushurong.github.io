<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.useso.com/css?family=Monda:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="final,static," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/head.ico?v=5.0.1" />






<meta name="description" content="Java关键字之final终态定义根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。
&amp;nbsp;
final类不能被继承，没有子类，final类中的方法默认是final的。final方法不能被子类的方法覆盖，但可以被继承。final成员变量表示常量，只能被赋值一次，赋值后值">
<meta property="og:type" content="article">
<meta property="og:title" content="Java之Static静态、final终态的详解">
<meta property="og:url" content="http://yoursite.com/2014/02/25/static-final/index.html">
<meta property="og:site_name" content="小树技术博客">
<meta property="og:description" content="Java关键字之final终态定义根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。
&amp;nbsp;
final类不能被继承，没有子类，final类中的方法默认是final的。final方法不能被子类的方法覆盖，但可以被继承。final成员变量表示常量，只能被赋值一次，赋值后值">
<meta property="og:updated_time" content="2016-04-28T14:05:28.751Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java之Static静态、final终态的详解">
<meta name="twitter:description" content="Java关键字之final终态定义根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。
&amp;nbsp;
final类不能被继承，没有子类，final类中的方法默认是final的。final方法不能被子类的方法覆盖，但可以被继承。final成员变量表示常量，只能被赋值一次，赋值后值">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 5322878,
      author: '小树'
    }
  };
</script>

  <title> Java之Static静态、final终态的详解 | 小树技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小树技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">用文字留住时间、用博客记录生命</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java之Static静态、final终态的详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-02-25T23:38:03+08:00" content="2014-02-25">
              2014-02-25
            </time>
          </span>

<span class="post-count">&nbsp; | &nbsp;字数 3,677</span>
<span class="post-count">&nbsp; | &nbsp;预计阅读 16分钟</span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java-SE/" itemprop="url" rel="index">
                    <span itemprop="name">Java SE</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/02/25/static-final/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/02/25/static-final/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java关键字之final终态定义"><a href="#Java关键字之final终态定义" class="headerlink" title="Java关键字之final终态定义"></a>Java关键字之final终态定义</h1><p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。</p>
<p>&nbsp;</p>
<p>final类不能被继承，没有子类，final类中的方法默认是final的。<br>final方法不能被子类的方法覆盖，但可以被继承。<br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>final不能用于修饰构造方法。<br>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p>
<p>&nbsp;</p>
<h2 id="1、修饰类"><a href="#1、修饰类" class="headerlink" title="1、修饰类"></a>1、修饰类</h2><p>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>
<h2 id="2、修饰方法"><a href="#2、修饰方法" class="headerlink" title="2、修饰方法"></a>2、修饰方法</h2><p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>使用final方法的原因有二：<br>第一、把方法锁定，防止任何继承类修改它的意义和实现。<br>第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。<br>例如：</p>
<p>&nbsp;</p>
<p><pre class="lang:java decode:true">package org.leizhimin; </pre></p>
<p>public class Test3 {<br>        private final String S = “final实例变量S”;<br>        private final int A = 100;<br>        public final int B = 90; </p>
<pre><code>public static final int C = 80; 
private static final int D = 70; 

public final int E; //final空白,必须在初始化对象的时候赋初值 

public Test3(int x) { 
        E = x; 
} 

/** 
 * @param args 
 */ 
public static void main(String[] args) { 
        Test3 t = new Test3(2); 
        //t.A=101;    //出错,final变量的值一旦给定就无法改变 
        //t.B=91; //出错,final变量的值一旦给定就无法改变 
        //t.C=81; //出错,final变量的值一旦给定就无法改变 
        //t.D=71; //出错,final变量的值一旦给定就无法改变 

        System.out.println(t.A); 
        System.out.println(t.B); 
        System.out.println(t.C); //不推荐用对象方式访问静态字段 
        System.out.println(t.D); //不推荐用对象方式访问静态字段 
        System.out.println(Test3.C); 
        System.out.println(Test3.D); 
        //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. 
        System.out.println(t.E); 

        Test3 t1 = new Test3(3); 
        System.out.println(t1.E); //final空白变量E依据对象的不同而不同 
} 

private void test() { 
        System.out.println(new Test3(1).A); 
        System.out.println(Test3.C); 
        System.out.println(Test3.D); 
} 

public void test2() { 
        final int a;     //final空白,在需要的时候才赋值 
        final int b = 4;    //局部常量--final用于局部变量的情形 
        final int c;    //final空白,一直没有给赋值.    
        a = 3; 
        //a=4;    出错,已经给赋过值了. 
        //b=2; 出错,已经给赋过值了. 
} 
</code></pre><p>}<br>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="3、修饰变量（常量）"><a href="#3、修饰变量（常量）" class="headerlink" title="3、修饰变量（常量）"></a>3、修饰变量（常量）</h2><p>用final修饰的成员变量表示常量，值一旦给定就无法改变！<br>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。<br>另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>
<p>&nbsp;</p>
<p><pre class="lang:java decode:true">public class Test1 {<br>    public static void main(String[] args) {<br>        // TODO 自动生成方法存根<br>    }<br>    public void f1() {<br>        System.out.println(“f1”);<br>    }<br>    //无法被子类覆盖的方法<br>    public final void f2() {<br>        System.out.println(“f2”);<br>    }<br>    public void f3() {<br>        System.out.println(“f3”);<br>    }<br>    private void f4() {<br>        System.out.println(“f4”);<br>    }<br>}<br>public class Test2 extends Test1 { </pre></p>
<pre><code>public void f1(){     
    System.out.println(&quot;Test1父类方法f1被覆盖!&quot;); 
} 
public static void main(String[] args) { 
    Test2 t=new Test2(); 
    t.f1();    
    t.f2(); //调用从父类继承过来的final方法 
    t.f3(); //调用从父类继承过来的方法 
    //t.f4(); //调用失败，无法从父类继承获得 
} 
</code></pre><p>}<br>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="4、修饰参数"><a href="#4、修饰参数" class="headerlink" title="4、修饰参数"></a>4、修饰参数</h2><p>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><pre class="lang:java decode:true">public class Test4 {<br>        public static void main(String[] args) {<br>                new Test4().f1(2);<br>        } </pre></p>
<pre><code>public void f1(final int i) { 
        //i++;    //i是final类型的,值不允许改变的. 
        System.out.print(i); 
} 
</code></pre><p>}<br>&nbsp;<br><!--nextpage--><br>&nbsp;</p>
<h1 id="Java关键字之static静态定义"><a href="#Java关键字之static静态定义" class="headerlink" title="Java关键字之static静态定义"></a>Java关键字之static静态定义</h1><p><strong>
</strong>        static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>
<p><strong>一、特点</strong></p>
<p>1、随着类的加载而加载，随着类的消失而消失，生命周期最长<br>2、优先于对象存在<br>3、被所有类的对象共享<br>4、可以直接被类名所调用<br>5、存放于栈内存中</p>
<p><strong>1**</strong>、利：**<br>1）对对象的共享数据进行单独空间的存储，节省空间</p>
<p>2）可以直接被类名调用</p>
<p><strong>2**</strong>、弊：**<br>1）生命周期过长</p>
<p>2）访问有局限性<br>被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。<br>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。</p>
<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：<br>类名.静态方法名(参数列表…)<br>类名.静态变量名</p>
<p>&nbsp;</p>
<p>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。</p>
<p>&nbsp;</p>
<h2 id="1、修饰变量"><a href="#1、修饰变量" class="headerlink" title="1、修饰变量"></a>1、修饰变量</h2><p>按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br>对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</p>
<p>&nbsp;</p>
<h2 id="2、修饰方法-1"><a href="#2、修饰方法-1" class="headerlink" title="2、修饰方法"></a>2、修饰方法</h2><p>静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br>因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>&nbsp;</p>
<h2 id="3、修饰代码块"><a href="#3、修饰代码块" class="headerlink" title="3、修饰代码块"></a>3、修饰代码块</h2><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><pre class="lang:java decode:true ">public class Test5 {<br>        private static int a;<br>        private int b; </pre></p>
<pre><code>static { 
        Test5.a = 3; 
        System.out.println(a); 
        Test5 t = new Test5(); 
        t.f(); 
        t.b = 1000; 
        System.out.println(t.b); 
} 

static { 
        Test5.a = 4; 
        System.out.println(a); 
} 

public static void main(String[] args) { 
        // TODO 自动生成方法存根 
} 

static { 
        Test5.a = 5; 
        System.out.println(a); 
} 

public void f() { 
        System.out.println(&quot;hhahhahah&quot;); 
} 
</code></pre><p>}</p>
<p>运行结果：<br>3<br>hhahhahah<br>1000<br>4<br>5<br>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="static和final同时使用"><a href="#static和final同时使用" class="headerlink" title="static和final同时使用"></a>static和final同时使用</h1><p>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
<p>特别要注意一个问题：</p>
<p>&nbsp;</p>
<p>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。</p>
<p>也许说了这么多，反倒把你搞晕了，还是看个例子吧：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><pre class="lang:java decode:true ">public class TestStaticFinal {<br>    private static final String strStaticFinalVar = “aaa”;<br>    private static String strStaticVar = null;<br>    private final String strFinalVar = null;<br>    private static final int intStaticFinalVar = 0;<br>    private static final Integer integerStaticFinalVar = new Integer(8);<br>    private static final ArrayList&lt;String&gt; alStaticFinalVar = new ArrayList&lt;String&gt;(); </pre></p>
<pre><code>private void test() { 
    System.out.println(&quot;-------------值处理前----------rn&quot;); 
    System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;rn&quot;); 
    System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;rn&quot;); 

    //strStaticFinalVar=&quot;哈哈哈哈&quot;;        //错误，final表示终态,不可以改变变量本身. 
    strStaticVar = &quot;哈哈哈哈&quot;;                //正确，static表示类变量,值可以改变. 
    //strFinalVar=&quot;呵呵呵呵&quot;;                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 
    //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 
    //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 
    alStaticFinalVar.add(&quot;aaa&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 
    alStaticFinalVar.add(&quot;bbb&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 

    System.out.println(&quot;-------------值处理后----------rn&quot;); 
    System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;rn&quot;); 
    System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;rn&quot;); 
    System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;rn&quot;); 
} 

public static void main(String args[]) { 
    new TestStaticFinal().test(); 
} 
</code></pre><p>}</p>
<p>运行结果如下：<br>————-值处理前———-<br>strStaticFinalVar=aaa<br>strStaticVar=null<br>strFinalVar=null<br>intStaticFinalVar=0<br>integerStaticFinalVar=8<br>alStaticFinalVar=[]<br>————-值处理后———-<br>strStaticFinalVar=aaa<br>strStaticVar=哈哈哈哈<br>strFinalVar=null<br>intStaticFinalVar=0<br>integerStaticFinalVar=8<br>alStaticFinalVar=[aaa, bbb]</p>
<p>Process finished with exit code 0<br>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>看了上面这个例子，就清楚很多了，但必须明白：通过static final修饰的容器类型变量中所“装”的对象是可改变的。这是和一般基本类型和类类型变量差别很大的地方。</p>
<p>&nbsp;</p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/final/" rel="tag">#final</a>
          
            <a href="/tags/static/" rel="tag">#static</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/02/24/kejie/" rel="next" title="软件-文件加密解密工具[克捷公司]">
                <i class="fa fa-chevron-left"></i> 软件-文件加密解密工具[克捷公司]
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/02/27/helloworld/" rel="prev" title="LibGDX游戏引擎-1-项目创建(HelloWorld)">
                LibGDX游戏引擎-1-项目创建(HelloWorld) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2014/02/25/static-final/"
     data-title="Java之Static静态、final终态的详解"
     data-content=""
     data-url="http://yoursite.com/2014/02/25/static-final/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2014/02/25/static-final/"
           data-title="Java之Static静态、final终态的详解" data-url="http://yoursite.com/2014/02/25/static-final/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="邱树荣" />
          <p class="site-author-name" itemprop="name">邱树荣</p>
          <p class="site-description motion-element" itemprop="description">致力于计算机程式开发</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">110</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">195</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java关键字之final终态定义"><span class="nav-number">1.</span> <span class="nav-text">Java关键字之final终态定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、修饰类"><span class="nav-number">1.1.</span> <span class="nav-text">1、修饰类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、修饰方法"><span class="nav-number">1.2.</span> <span class="nav-text">2、修饰方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、修饰变量（常量）"><span class="nav-number">1.3.</span> <span class="nav-text">3、修饰变量（常量）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、修饰参数"><span class="nav-number">1.4.</span> <span class="nav-text">4、修饰参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java关键字之static静态定义"><span class="nav-number">2.</span> <span class="nav-text">Java关键字之static静态定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、修饰变量"><span class="nav-number">2.1.</span> <span class="nav-text">1、修饰变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、修饰方法-1"><span class="nav-number">2.2.</span> <span class="nav-text">2、修饰方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、修饰代码块"><span class="nav-number">2.3.</span> <span class="nav-text">3、修饰代码块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static和final同时使用"><span class="nav-number">3.</span> <span class="nav-text">static和final同时使用</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="powered-by" >
  
  <span itemprop="copyrightYear">&copy;2016 - 2026</span>

  <a style="" class="theme-link" href="https://qiushurong.github.io">
    小树技术博客
  </a>

</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  粤ICP备<a class="theme-link" href="https://qiushurong.github.io">
    15021480
  </a>号
</div>

        

        
      </div>
    </footer>

    <!--qsuron20160418 返回顶部更换为火箭
    div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div-->

    <a id="rocket" href="#top" class=""></a>


  </div>


  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"qsuron"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  

</body>
</html>
